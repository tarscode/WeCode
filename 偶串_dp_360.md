# 偶串

> 作者：张鹤
> 日期：2017.6.5

题目链接：http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3980&konwledgeId=42

## 内容

### 正文

一个字符串S是偶串当且仅当S中的每一个字符都出现了偶数次。如字符串”aabccb”是一个偶串，因为字符a,b,c都出现了两次。而字符串”abbcc”不是偶串，因为字符a出现了一次。

现在给出一个长度为n的字符串T=t1,t2,t3,…,tn。字符串的子串为其中任意连续一段。T长度为1的子串有n个，长度为2的子串有n-1个，以此类推，T一共有n(n+1)/2个子串。给定T，你能算出它有多少个子串是偶串吗？

### 输入描述

```
输入一个字符串T，T中只有小写字母。T的长度不超过100000。
```

### 输出描述

```
输出一个数，T的所有子串中偶串的个数。
```

### 输入


```
abbc
```

### 输出


```
1
```

## 分析

将思路转化一下，可以将每一个字符'a'，'b'，'c'都看成一串2进制的数。利用异或，相同得0，不同得1的思想。

首先设dp[i]：s[0]^s[1]...^s[i]。所以可以得到dp[i]=dp[i-1]^s[i]。

如果dp[i]=0，则说明s[0...i]必为偶串，如果dp[i]!=0，则说明s[0...i]不是偶串。但是，偶串不只是从头开始，也可以从中间开始，那么如何计算共有多少个偶串呢？

我们已经知道如果一个串是偶串的话，它的异或结果必为0。这就说明在对字符串进行从头到尾遍历的时候，如果有dp[i]==dp[j]的话，说明s[i+1...j]的异或结果是0，也就是说明s[i+1...j]是偶串。所以，只要在从头至尾的遍历过程中，只要出现dp[i]==dp[j]的情况，就可以确定又出现了一个偶串s[i+1...j]。

为了记录s[0...i]的异或值，也就是dp[i]的值，我们设置一个map，它的key是在遍历字符串s的过程中，dp[i]的值；value是大小等于dp[i]的值出现的次数。

最终的结果res=res+map.get(dp[i])。就是每当出现一个偶串的时候，用当前已有的偶串数res，加上在遍历过程中出现值dp[i]的次数。这样得到的数值就是遍历到当前位置，所出现的偶串数目。

为什么要加上在遍历过程中出现值dp[i]的次数呢？

这是因为：假如遍历到当前位置k得到的dp[k]==dp[i]，并且在map中dp[i]的值为2。这就说明从s[i]到s[k]为止已经有两个异或值为dp[i]的偶串了，假设这两个偶串为a和b。由于b是新加入的偶串，所以我们需要将以b结尾的新偶串计算进结果中。以b结尾的偶串除了b本身之外，还有一个ab，正好是两个，也就是从位置i到位置k出现的偶串个数。以此类推。

注意，需要将map的key=0的情况设置为1。这是一个初始化过程。因为在我们的计算偶串个数的过程中，如果出现的字符串s为"aabc"这种开头就是偶串的情况，我们的计算方法，如果不事先将map的key=0的情况设置为1，那么aa的异或结果将是第一次出现异或值等于0的情况，此时才将0添加进入map将会导致计算结果错误。而且，也可以理解为，当字符串为空的时候也可以算作一个偶串，所以将map的key=0的情况初始化为1.

## 解法

#### 思路

1. ​

复杂分析

- 时间复杂度O(n)
- 空间复杂度O(n)

#### 注释

#### 代码


```java
public class EvenString {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String s = in.next();
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0,1); //初始化map，将异或为0的情况添加进去。
        int xor = 0; //异或结果
        int res = 0; //偶串个数计数
        for (int i = 0; i < s.length(); i++) {
            int cur = s.charAt(i)-'a'; //计算当前位置的字符数值，如果是a就是0，b就是1，以此类推
			//1 << cur就是让1向左移位cur这么多位，其实就是a就是..01，b就是...010，每个字母只有一位为1
            xor ^= (1 << cur); 
            if (map.containsKey(xor)){ //判断异或结果以前是否出现过
                res += map.get(xor); 
                map.put(xor, map.get(xor)+1); 
            }else //否则将该结果添加进入map
                map.put(xor,1);
        }
        System.out.println(res);
    }
}
```


### 