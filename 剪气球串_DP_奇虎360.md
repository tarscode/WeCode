# 剪气球串

> 刘洋
> 2017.6.5

题目链接：http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3862&konwledgeId=42

## 内容

### 正文

小明买了一些彩色的气球用绳子串在一条线上，想要装饰房间，每个气球都染上了一种颜色，每个气球的形状都是各不相同的。我们用1到9一共9个数字表示不同的颜色，如12345则表示一串5个颜色各不相同的气球串。但小明希望得到不出现重复颜色的气球串，那么现在小明需要将这个气球串剪成多个较短的气球串，小明一共有多少种剪法？如原气球串12345的一种是剪法是剪成12和345两个气球串。

注意每种剪法需满足最后的子串中气球颜色各不相同（如果满足该条件，允许不剪，即保留原串）。两种剪法不同当且仅当存在一个位置，在一种剪法里剪开了，而在另一种中没剪开。详见样例分析。

### 输入

第一行输入一个正整数n（1≤n≤100000），表示气球的数量。
第二行输入n个整数a1，a2，a3...an，ai表示该气球串上第i个气球的颜色。对于任意i，有1≤ai≤9。

```
3
1 2 3
```

### 输出

输出一行，第一行输出一个整数，表示满足要求的剪法，输出最终结果除以1000000007后的余数。

```
4
```

## 分析

本质上求出有序数组中两个最大的差值，即后面元素减去前面元素的最大值


## 解法

### 方法一:DP法

#### 思路

气球颜色数组arr,i从1到n,数组dp[i]表示前i个气球有多少种剪法,map表示某种颜色的气球数目

1. 遍历arr[i]
2. 从i-1到0计算dp[j]的值,依次累加;若map[arr[j]]==2,表示arr[j]至arr[i]中有颜色重复,停止计算
3. 输出dp[n]

复杂分析

- 时间复杂度O(n2)
- 空间复杂度O(n)

#### 备注

- 注意气球颜色数组从arr[1]开始输入赋值,处理arr[i]和arr[0]相等的情况

#### 代码

```
public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n+1]; //气球颜色数组
        arr[0] = 0;
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }
        int[] dp = new int[n+1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            int[] map = new int[10];//记录每个颜色气球出现颜色的数目
            for (int j = i; j >= 1; j--) {
                if (map[arr[j]]++ >= 1) { //有颜色重复
                    break;
                }
                dp[i] = (dp[i] + dp[j - 1]) % 1000000007;
            }
        }
        System.out.println(dp[n]);
    }
}
```